{"ast":null,"code":"// =============================\n// Email: info@ebenmonney.com\n// www.ebenmonney.com/templates\n// =============================\n\n/**\r\n * alertify\r\n * An unobtrusive customizable JavaScript notification system\r\n *\r\n * @author Fabien Doiron <fabien.doiron@gmail.com>\r\n * @copyright Fabien Doiron 2013\r\n * @license MIT <http://opensource.org/licenses/mit-license.php>\r\n * @link http://fabien-d.github.com/alertify.js/\r\n * @module alertify\r\n * @version 0.3.11\r\n */\n(function (global, undefined) {\n  \"use strict\";\n\n  var document = global.document,\n      Alertify;\n\n  Alertify = function () {\n    var _alertify = {},\n        dialogs = {},\n        isopen = false,\n        keys = {\n      ENTER: 13,\n      ESC: 27,\n      SPACE: 32\n    },\n        queue = [],\n        $,\n        btnCancel,\n        btnOK,\n        btnReset,\n        btnResetBack,\n        btnFocus,\n        elCallee,\n        elCover,\n        elDialog,\n        elLog,\n        form,\n        input,\n        getTransitionEvent;\n    /**\r\n     * Markup pieces\r\n     * @type {Object}\r\n     */\n\n    dialogs = {\n      buttons: {\n        holder: \"<nav class=\\\"alertify-buttons\\\">{{buttons}}</nav>\",\n        submit: \"<button type=\\\"submit\\\" class=\\\"alertify-button alertify-button-ok\\\" id=\\\"alertify-ok\\\">{{ok}}</button>\",\n        ok: \"<button class=\\\"alertify-button alertify-button-ok\\\" id=\\\"alertify-ok\\\">{{ok}}</button>\",\n        cancel: \"<button class=\\\"alertify-button alertify-button-cancel\\\" id=\\\"alertify-cancel\\\">{{cancel}}</button>\"\n      },\n      input: \"<div class=\\\"alertify-text-wrapper\\\"><input type=\\\"text\\\" class=\\\"alertify-text\\\" id=\\\"alertify-text\\\"></div>\",\n      message: \"<p class=\\\"alertify-message\\\">{{message}}</p>\",\n      log: \"<article class=\\\"alertify-log{{class}}\\\">{{message}}</article>\"\n    };\n    /**\r\n     * Return the proper transitionend event\r\n     * @return {String}    Transition type string\r\n     */\n\n    getTransitionEvent = function () {\n      var t,\n          type,\n          supported = false,\n          el = document.createElement(\"fakeelement\"),\n          transitions = {\n        \"WebkitTransition\": \"webkitTransitionEnd\",\n        \"MozTransition\": \"transitionend\",\n        \"OTransition\": \"otransitionend\",\n        \"transition\": \"transitionend\"\n      };\n\n      for (t in transitions) {\n        if (el.style[t] !== undefined) {\n          type = transitions[t];\n          supported = true;\n          break;\n        }\n      }\n\n      return {\n        type: type,\n        supported: supported\n      };\n    };\n    /**\r\n     * Shorthand for document.getElementById()\r\n     *\r\n     * @param  {String} id    A specific element ID\r\n     * @return {Object}       HTML element\r\n     */\n\n\n    $ = function (id) {\n      return document.getElementById(id);\n    };\n    /**\r\n     * Alertify private object\r\n     * @type {Object}\r\n     */\n\n\n    _alertify = {\n      /**\r\n       * Labels object\r\n       * @type {Object}\r\n       */\n      labels: {\n        ok: \"OK\",\n        cancel: \"Cancel\"\n      },\n\n      /**\r\n       * Delay number\r\n       * @type {Number}\r\n       */\n      delay: 5000,\n\n      /**\r\n       * Whether buttons are reversed (default is secondary/primary)\r\n       * @type {Boolean}\r\n       */\n      buttonReverse: false,\n\n      /**\r\n       * Which button should be focused by default\r\n       * @type {String}\t\"ok\" (default), \"cancel\", or \"none\"\r\n       */\n      buttonFocus: \"ok\",\n\n      /**\r\n       * Set the transition event on load\r\n       * @type {[type]}\r\n       */\n      transition: undefined,\n\n      /**\r\n       * Set the proper button click events\r\n       *\r\n       * @param {Function} fn    [Optional] Callback function\r\n       *\r\n       * @return {undefined}\r\n       */\n      addListeners: function (fn) {\n        var hasOK = typeof btnOK !== \"undefined\",\n            hasCancel = typeof btnCancel !== \"undefined\",\n            hasInput = typeof input !== \"undefined\",\n            val = \"\",\n            self = this,\n            ok,\n            cancel,\n            common,\n            key,\n            reset; // ok event handler\n\n        ok = function (event) {\n          if (typeof event.preventDefault !== \"undefined\") event.preventDefault();\n          common(event);\n          if (typeof input !== \"undefined\") val = input.value;\n\n          if (typeof fn === \"function\") {\n            if (typeof input !== \"undefined\") {\n              fn(true, val);\n            } else fn(true);\n          }\n\n          return false;\n        }; // cancel event handler\n\n\n        cancel = function (event) {\n          if (typeof event.preventDefault !== \"undefined\") event.preventDefault();\n          common(event);\n          if (typeof fn === \"function\") fn(false);\n          return false;\n        }; // common event handler (keyup, ok and cancel)\n\n\n        common = function (event) {\n          self.hide();\n          self.unbind(document.body, \"keyup\", key);\n          self.unbind(btnReset, \"focus\", reset);\n          if (hasOK) self.unbind(btnOK, \"click\", ok);\n          if (hasCancel) self.unbind(btnCancel, \"click\", cancel);\n        }; // keyup handler\n\n\n        key = function (event) {\n          var keyCode = event.keyCode;\n          if (keyCode === keys.SPACE && !hasInput || hasInput && keyCode === keys.ENTER) ok(event);\n          if (keyCode === keys.ESC && hasCancel) cancel(event);\n        }; // reset focus to first item in the dialog\n\n\n        reset = function (event) {\n          if (hasInput) input.focus();else if (!hasCancel || self.buttonReverse) btnOK.focus();else btnCancel.focus();\n        }; // handle reset focus link\n        // this ensures that the keyboard focus does not\n        // ever leave the dialog box until an action has\n        // been taken\n\n\n        this.bind(btnReset, \"focus\", reset);\n        this.bind(btnResetBack, \"focus\", reset); // handle OK click\n\n        if (hasOK) this.bind(btnOK, \"click\", ok); // handle Cancel click\n\n        if (hasCancel) this.bind(btnCancel, \"click\", cancel); // listen for keys, Cancel => ESC\n\n        this.bind(document.body, \"keyup\", key);\n\n        if (!this.transition.supported) {\n          this.setFocus();\n        }\n      },\n\n      /**\r\n       * Bind events to elements\r\n       *\r\n       * @param  {Object}   el       HTML Object\r\n       * @param  {Event}    event    Event to attach to element\r\n       * @param  {Function} fn       Callback function\r\n       *\r\n       * @return {undefined}\r\n       */\n      bind: function (el, event, fn) {\n        if (typeof el.addEventListener === \"function\") {\n          el.addEventListener(event, fn, false);\n        } else if (el.attachEvent) {\n          el.attachEvent(\"on\" + event, fn);\n        }\n      },\n\n      /**\r\n       * Use alertify as the global error handler (using window.onerror)\r\n       *\r\n       * @return {boolean} success\r\n       */\n      handleErrors: function () {\n        if (typeof global.onerror !== \"undefined\") {\n          var self = this;\n\n          global.onerror = function (msg, url, line) {\n            self.error(\"[\" + msg + \" on line \" + line + \" of \" + url + \"]\", 0);\n          };\n\n          return true;\n        } else {\n          return false;\n        }\n      },\n\n      /**\r\n       * Append button HTML strings\r\n       *\r\n       * @param {String} secondary    The secondary button HTML string\r\n       * @param {String} primary      The primary button HTML string\r\n       *\r\n       * @return {String}             The appended button HTML strings\r\n       */\n      appendButtons: function (secondary, primary) {\n        return this.buttonReverse ? primary + secondary : secondary + primary;\n      },\n\n      /**\r\n       * Build the proper message box\r\n       *\r\n       * @param  {Object} item    Current object in the queue\r\n       *\r\n       * @return {String}         An HTML string of the message box\r\n       */\n      build: function (item) {\n        var html = \"\",\n            type = item.type,\n            message = item.message,\n            css = item.cssClass || \"\";\n        html += \"<div class=\\\"alertify-dialog\\\">\";\n        html += \"<a id=\\\"alertify-resetFocusBack\\\" class=\\\"alertify-resetFocus\\\" href=\\\"#\\\">Reset Focus</a>\";\n        if (_alertify.buttonFocus === \"none\") html += \"<a href=\\\"#\\\" id=\\\"alertify-noneFocus\\\" class=\\\"alertify-hidden\\\"></a>\"; // doens't require an actual form\n\n        if (type === \"prompt\") html += \"<div id=\\\"alertify-form\\\">\";\n        html += \"<article class=\\\"alertify-inner\\\">\";\n        html += dialogs.message.replace(\"{{message}}\", message);\n        if (type === \"prompt\") html += dialogs.input;\n        html += dialogs.buttons.holder;\n        html += \"</article>\";\n        if (type === \"prompt\") html += \"</div>\";\n        html += \"<a id=\\\"alertify-resetFocus\\\" class=\\\"alertify-resetFocus\\\" href=\\\"#\\\">Reset Focus</a>\";\n        html += \"</div>\";\n\n        switch (type) {\n          case \"confirm\":\n            html = html.replace(\"{{buttons}}\", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.ok));\n            html = html.replace(\"{{ok}}\", this.labels.ok).replace(\"{{cancel}}\", this.labels.cancel);\n            break;\n\n          case \"prompt\":\n            html = html.replace(\"{{buttons}}\", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.submit));\n            html = html.replace(\"{{ok}}\", this.labels.ok).replace(\"{{cancel}}\", this.labels.cancel);\n            break;\n\n          case \"alert\":\n            html = html.replace(\"{{buttons}}\", dialogs.buttons.ok);\n            html = html.replace(\"{{ok}}\", this.labels.ok);\n            break;\n\n          default:\n            break;\n        }\n\n        elDialog.className = \"alertify alertify-\" + type + \" \" + css;\n        elCover.className = \"alertify-cover\";\n        return html;\n      },\n\n      /**\r\n       * Close the log messages\r\n       *\r\n       * @param  {Object} elem    HTML Element of log message to close\r\n       * @param  {Number} wait    [optional] Time (in ms) to wait before automatically hiding the message, if 0 never hide\r\n       *\r\n       * @return {undefined}\r\n       */\n      close: function (elem, wait) {\n        // Unary Plus: +\"2\" === 2\n        var timer = wait && !isNaN(wait) ? +wait : this.delay,\n            self = this,\n            hideElement,\n            transitionDone; // set click event on log messages\n\n        this.bind(elem, \"click\", function () {\n          hideElement(elem);\n        }); // Hide the dialog box after transition\n        // This ensure it doens't block any element from being clicked\n\n        transitionDone = function (event) {\n          event.stopPropagation(); // unbind event so function only gets called once\n\n          self.unbind(this, self.transition.type, transitionDone); // remove log message\n\n          elLog.removeChild(this);\n          if (!elLog.hasChildNodes()) elLog.className += \" alertify-logs-hidden\";\n        }; // this sets the hide class to transition out\n        // or removes the child if css transitions aren't supported\n\n\n        hideElement = function (el) {\n          // ensure element exists\n          if (typeof el !== \"undefined\" && el.parentNode === elLog) {\n            // whether CSS transition exists\n            if (self.transition.supported) {\n              self.bind(el, self.transition.type, transitionDone);\n              el.className += \" alertify-log-hide\";\n            } else {\n              elLog.removeChild(el);\n              if (!elLog.hasChildNodes()) elLog.className += \" alertify-logs-hidden\";\n            }\n          }\n        }; // never close (until click) if wait is set to 0\n\n\n        if (wait === 0) return; // set timeout to auto close the log message\n\n        setTimeout(function () {\n          hideElement(elem);\n        }, timer);\n      },\n\n      /**\r\n       * Create a dialog box\r\n       *\r\n       * @param  {String}   message        The message passed from the callee\r\n       * @param  {String}   type           Type of dialog to create\r\n       * @param  {Function} fn             [Optional] Callback function\r\n       * @param  {String}   placeholder    [Optional] Default value for prompt input field\r\n       * @param  {String}   cssClass       [Optional] Class(es) to append to dialog box\r\n       *\r\n       * @return {Object}\r\n       */\n      dialog: function (message, type, fn, placeholder, cssClass) {\n        // set the current active element\n        // this allows the keyboard focus to be resetted\n        // after the dialog box is closed\n        elCallee = document.activeElement; // check to ensure the alertify dialog element\n        // has been successfully created\n\n        var check = function () {\n          if (elLog && elLog.scrollTop !== null && elCover && elCover.scrollTop !== null) return;else check();\n        }; // error catching\n\n\n        if (typeof message !== \"string\") throw new Error(\"message must be a string\");\n        if (typeof type !== \"string\") throw new Error(\"type must be a string\");\n        if (typeof fn !== \"undefined\" && typeof fn !== \"function\") throw new Error(\"fn must be a function\"); // initialize alertify if it hasn't already been done\n\n        this.init();\n        check();\n        queue.push({\n          type: type,\n          message: message,\n          callback: fn,\n          placeholder: placeholder,\n          cssClass: cssClass\n        });\n        if (!isopen) this.setup();\n        return this;\n      },\n\n      /**\r\n       * Extend the log method to create custom methods\r\n       *\r\n       * @param  {String} type    Custom method name\r\n       *\r\n       * @return {Function}\r\n       */\n      extend: function (type) {\n        if (typeof type !== \"string\") throw new Error(\"extend method must have exactly one paramter\");\n        return function (message, wait) {\n          this.log(message, type, wait);\n          return this;\n        };\n      },\n\n      /**\r\n       * Hide the dialog and rest to defaults\r\n       *\r\n       * @return {undefined}\r\n       */\n      hide: function () {\n        var transitionDone,\n            self = this; // remove reference from queue\n\n        queue.splice(0, 1); // if items remaining in the queue\n\n        if (queue.length > 0) this.setup(true);else {\n          isopen = false; // Hide the dialog box after transition\n          // This ensure it doens't block any element from being clicked\n\n          transitionDone = function (event) {\n            event.stopPropagation(); // unbind event so function only gets called once\n\n            self.unbind(elDialog, self.transition.type, transitionDone);\n          }; // whether CSS transition exists\n\n\n          if (this.transition.supported) {\n            this.bind(elDialog, this.transition.type, transitionDone);\n            elDialog.className = \"alertify alertify-hide alertify-hidden\";\n          } else {\n            elDialog.className = \"alertify alertify-hide alertify-hidden alertify-isHidden\";\n          }\n\n          elCover.className = \"alertify-cover alertify-cover-hidden\"; // set focus to the last element or body\n          // after the dialog is closed\n\n          elCallee.focus();\n        }\n      },\n\n      /**\r\n       * Initialize Alertify\r\n       * Create the 2 main elements\r\n       *\r\n       * @return {undefined}\r\n       */\n      init: function () {\n        // ensure legacy browsers support html5 tags\n        document.createElement(\"nav\");\n        document.createElement(\"article\");\n        document.createElement(\"section\"); // cover\n\n        if ($(\"alertify-cover\") == null) {\n          elCover = document.createElement(\"div\");\n          elCover.setAttribute(\"id\", \"alertify-cover\");\n          elCover.className = \"alertify-cover alertify-cover-hidden\";\n          document.body.appendChild(elCover);\n        } // main element\n\n\n        if ($(\"alertify\") == null) {\n          isopen = false;\n          queue = [];\n          elDialog = document.createElement(\"section\");\n          elDialog.setAttribute(\"id\", \"alertify\");\n          elDialog.className = \"alertify alertify-hidden\";\n          document.body.appendChild(elDialog);\n        } // log element\n\n\n        if ($(\"alertify-logs\") == null) {\n          elLog = document.createElement(\"section\");\n          elLog.setAttribute(\"id\", \"alertify-logs\");\n          elLog.className = \"alertify-logs alertify-logs-hidden\";\n          document.body.appendChild(elLog);\n        } // set tabindex attribute on body element\n        // this allows script to give it focus\n        // after the dialog is closed\n\n\n        document.body.setAttribute(\"tabindex\", \"0\"); // set transition type\n\n        this.transition = getTransitionEvent();\n      },\n\n      /**\r\n       * Show a new log message box\r\n       *\r\n       * @param  {String} message    The message passed from the callee\r\n       * @param  {String} type       [Optional] Optional type of log message\r\n       * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding the log\r\n       *\r\n       * @return {Object}\r\n       */\n      log: function (message, type, wait) {\n        // check to ensure the alertify dialog element\n        // has been successfully created\n        var check = function () {\n          if (elLog && elLog.scrollTop !== null) return;else check();\n        }; // initialize alertify if it hasn't already been done\n\n\n        this.init();\n        check();\n        elLog.className = \"alertify-logs\";\n        this.notify(message, type, wait);\n        return this;\n      },\n\n      /**\r\n       * Add new log message\r\n       * If a type is passed, a class name \"alertify-log-{type}\" will get added.\r\n       * This allows for custom look and feel for various types of notifications.\r\n       *\r\n       * @param  {String} message    The message passed from the callee\r\n       * @param  {String} type       [Optional] Type of log message\r\n       * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding\r\n       *\r\n       * @return {undefined}\r\n       */\n      notify: function (message, type, wait) {\n        var log = document.createElement(\"article\");\n        log.className = \"alertify-log\" + (typeof type === \"string\" && type !== \"\" ? \" alertify-log-\" + type : \"\");\n        log.innerHTML = message; // append child\n\n        elLog.appendChild(log); // triggers the CSS animation\n\n        setTimeout(function () {\n          log.className = log.className + \" alertify-log-show\";\n        }, 50);\n        this.close(log, wait);\n      },\n\n      /**\r\n       * Set properties\r\n       *\r\n       * @param {Object} args     Passing parameters\r\n       *\r\n       * @return {undefined}\r\n       */\n      set: function (args) {\n        var k; // error catching\n\n        if (typeof args !== \"object\" && args instanceof Array) throw new Error(\"args must be an object\"); // set parameters\n\n        for (k in args) {\n          if (args.hasOwnProperty(k)) {\n            this[k] = args[k];\n          }\n        }\n      },\n\n      /**\r\n       * Common place to set focus to proper element\r\n       *\r\n       * @return {undefined}\r\n       */\n      setFocus: function () {\n        if (input) {\n          input.focus();\n          input.select();\n        } else btnFocus.focus();\n      },\n\n      /**\r\n       * Initiate all the required pieces for the dialog box\r\n       *\r\n       * @return {undefined}\r\n       */\n      setup: function (fromQueue) {\n        var item = queue[0],\n            self = this,\n            transitionDone; // dialog is open\n\n        isopen = true; // Set button focus after transition\n\n        transitionDone = function (event) {\n          event.stopPropagation();\n          self.setFocus(); // unbind event so function only gets called once\n\n          self.unbind(elDialog, self.transition.type, transitionDone);\n        }; // whether CSS transition exists\n\n\n        if (this.transition.supported && !fromQueue) {\n          this.bind(elDialog, this.transition.type, transitionDone);\n        } // build the proper dialog HTML\n\n\n        elDialog.innerHTML = this.build(item); // assign all the common elements\n\n        btnReset = $(\"alertify-resetFocus\");\n        btnResetBack = $(\"alertify-resetFocusBack\");\n        btnOK = $(\"alertify-ok\") || undefined;\n        btnCancel = $(\"alertify-cancel\") || undefined;\n        btnFocus = _alertify.buttonFocus === \"cancel\" ? btnCancel : _alertify.buttonFocus === \"none\" ? $(\"alertify-noneFocus\") : btnOK, input = $(\"alertify-text\") || undefined;\n        form = $(\"alertify-form\") || undefined; // add placeholder value to the input field\n\n        if (typeof item.placeholder === \"string\" && item.placeholder !== \"\") input.value = item.placeholder;\n        if (fromQueue) this.setFocus();\n        this.addListeners(item.callback);\n      },\n\n      /**\r\n       * Unbind events to elements\r\n       *\r\n       * @param  {Object}   el       HTML Object\r\n       * @param  {Event}    event    Event to detach to element\r\n       * @param  {Function} fn       Callback function\r\n       *\r\n       * @return {undefined}\r\n       */\n      unbind: function (el, event, fn) {\n        if (typeof el.removeEventListener === \"function\") {\n          el.removeEventListener(event, fn, false);\n        } else if (el.detachEvent) {\n          el.detachEvent(\"on\" + event, fn);\n        }\n      }\n    };\n    return {\n      alert: function (message, fn, cssClass) {\n        _alertify.dialog(message, \"alert\", fn, \"\", cssClass);\n\n        return this;\n      },\n      confirm: function (message, fn, cssClass) {\n        _alertify.dialog(message, \"confirm\", fn, \"\", cssClass);\n\n        return this;\n      },\n      extend: _alertify.extend,\n      init: _alertify.init,\n      log: function (message, type, wait) {\n        _alertify.log(message, type, wait);\n\n        return this;\n      },\n      prompt: function (message, fn, placeholder, cssClass) {\n        _alertify.dialog(message, \"prompt\", fn, placeholder, cssClass);\n\n        return this;\n      },\n      success: function (message, wait) {\n        _alertify.log(message, \"success\", wait);\n\n        return this;\n      },\n      error: function (message, wait) {\n        _alertify.log(message, \"error\", wait);\n\n        return this;\n      },\n      set: function (args) {\n        _alertify.set(args);\n      },\n      labels: _alertify.labels,\n      debug: _alertify.handleErrors\n    };\n  }; // AMD and window support\n\n\n  if (typeof define === \"function\") {\n    define([], function () {\n      return new Alertify();\n    });\n  } else if (typeof global.alertify === \"undefined\") {\n    global.alertify = new Alertify();\n  }\n})(window);","map":null,"metadata":{},"sourceType":"script"}