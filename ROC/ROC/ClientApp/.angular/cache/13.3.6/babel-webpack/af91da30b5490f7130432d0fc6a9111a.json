{"ast":null,"code":"import { HttpResponseBase, HttpResponse, HttpErrorResponse } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nexport let Utilities = /*#__PURE__*/(() => {\n  class Utilities {\n    static getHttpResponseMessages(data) {\n      const responses = [];\n\n      if (data instanceof HttpResponseBase) {\n        if (this.checkNoNetwork(data)) {\n          responses.push(`${this.noNetworkMessageCaption}${this.captionAndMessageSeparator} ${this.noNetworkMessageDetail}`);\n        } else {\n          const responseObject = this.getResponseBody(data);\n\n          if (responseObject && (typeof responseObject === 'object' || responseObject instanceof Object)) {\n            for (const key in responseObject) {\n              if (key) {\n                responses.push(`${key}${this.captionAndMessageSeparator} ${responseObject[key]}`);\n              } else if (responseObject[key]) {\n                responses.push(responseObject[key].toString());\n              }\n            }\n          }\n        }\n\n        if (!responses.length) {\n          if (data.body) {\n            responses.push(`body: ${data.body}`);\n          }\n\n          if (data.error) {\n            responses.push(`error: ${data.error}`);\n          }\n        }\n      }\n\n      if (!responses.length) {\n        if (this.getResponseBody(data)) {\n          responses.push(this.getResponseBody(data).toString());\n        } else {\n          responses.push(data.toString());\n        }\n      }\n\n      if (this.checkAccessDenied(data)) {\n        responses.splice(0, 0, `${this.accessDeniedMessageCaption}${this.captionAndMessageSeparator} ${this.accessDeniedMessageDetail}`);\n      }\n\n      if (this.checkNotFound(data)) {\n        let message = `${this.notFoundMessageCaption}${this.captionAndMessageSeparator} ${this.notFoundMessageDetail}`;\n\n        if (data.url) {\n          message += `. ${data.url}`;\n        }\n\n        responses.splice(0, 0, message);\n      }\n\n      return responses;\n    }\n\n    static getHttpResponseMessage(data) {\n      const httpMessage = Utilities.findHttpResponseMessage(Utilities.noNetworkMessageCaption, data) || Utilities.findHttpResponseMessage(Utilities.notFoundMessageCaption, data) || Utilities.findHttpResponseMessage('error_description', data) || Utilities.findHttpResponseMessage('error', data) || Utilities.getHttpResponseMessages(data).join();\n      return httpMessage;\n    }\n\n    static findHttpResponseMessage(messageToFind, data, seachInCaptionOnly = true, includeCaptionInResult = false) {\n      const searchString = messageToFind.toLowerCase();\n      const httpMessages = this.getHttpResponseMessages(data);\n\n      for (const message of httpMessages) {\n        const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);\n\n        if (fullMessage.firstPart && fullMessage.firstPart.toLowerCase().indexOf(searchString) !== -1) {\n          return includeCaptionInResult ? message : fullMessage.secondPart || fullMessage.firstPart;\n        }\n      }\n\n      if (!seachInCaptionOnly) {\n        for (const message of httpMessages) {\n          if (message.toLowerCase().indexOf(searchString) !== -1) {\n            if (includeCaptionInResult) {\n              return message;\n            } else {\n              const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);\n              return fullMessage.secondPart || fullMessage.firstPart;\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n\n    static getResponseBody(response) {\n      if (response instanceof HttpResponse) {\n        return response.body;\n      }\n\n      if (response instanceof HttpErrorResponse) {\n        return response.error || response.message || response.statusText;\n      }\n    }\n\n    static checkNoNetwork(response) {\n      if (response instanceof HttpResponseBase) {\n        return response.status === 0;\n      }\n\n      return false;\n    }\n\n    static checkAccessDenied(response) {\n      if (response instanceof HttpResponseBase) {\n        return response.status === 403;\n      }\n\n      return false;\n    }\n\n    static checkNotFound(response) {\n      if (response instanceof HttpResponseBase) {\n        return response.status === 404;\n      }\n\n      return false;\n    }\n\n    static checkIsLocalHost(url, base) {\n      if (url) {\n        const location = new URL(url, base);\n        return location.hostname === 'localhost' || location.hostname === '127.0.0.1';\n      }\n\n      return false;\n    }\n\n    static getQueryParamsFromString(paramString) {\n      if (!paramString) {\n        return null;\n      }\n\n      const params = {};\n\n      for (const param of paramString.split('&')) {\n        const keyValue = Utilities.splitInTwo(param, '=');\n        params[keyValue.firstPart] = keyValue.secondPart;\n      }\n\n      return params;\n    }\n\n    static splitInTwo(text, separator) {\n      const separatorIndex = text.indexOf(separator);\n\n      if (separatorIndex === -1) {\n        return {\n          firstPart: text,\n          secondPart: null\n        };\n      }\n\n      const part1 = text.substr(0, separatorIndex).trim();\n      const part2 = text.substr(separatorIndex + 1).trim();\n      return {\n        firstPart: part1,\n        secondPart: part2\n      };\n    }\n\n    static safeStringify(object) {\n      let result;\n\n      try {\n        result = JSON.stringify(object);\n        return result;\n      } catch (error) {}\n\n      const simpleObject = {};\n\n      for (const prop in object) {\n        if (!object.hasOwnProperty(prop)) {\n          continue;\n        }\n\n        if (typeof object[prop] === 'object') {\n          continue;\n        }\n\n        if (typeof object[prop] === 'function') {\n          continue;\n        }\n\n        simpleObject[prop] = object[prop];\n      }\n\n      result = '[***Sanitized Object***]: ' + JSON.stringify(simpleObject);\n      return result;\n    }\n\n    static JsonTryParse(value) {\n      try {\n        return JSON.parse(value);\n      } catch (e) {\n        if (value === 'undefined') {\n          return void 0;\n        }\n\n        return value;\n      }\n    }\n\n    static GetObjectWithLoweredPropertyNames(obj) {\n      const loweredObj = Object.keys(obj).reduce((newObj, k) => {\n        newObj[k.toLowerCase()] = obj[k];\n        return newObj;\n      }, {});\n      return loweredObj;\n    }\n\n    static TestIsObjectEmpty(obj) {\n      for (const prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    static TestIsUndefined(value) {\n      return typeof value === 'undefined'; // return value === undefined;\n    }\n\n    static TestIsString(value) {\n      return typeof value === 'string' || value instanceof String;\n    }\n\n    static capitalizeFirstLetter(text) {\n      if (text) {\n        return text.charAt(0).toUpperCase() + text.slice(1);\n      } else {\n        return text;\n      }\n    }\n\n    static toTitleCase(text) {\n      return text.replace(/\\w\\S*/g, subString => {\n        return subString.charAt(0).toUpperCase() + subString.substr(1).toLowerCase();\n      });\n    }\n\n    static toLowerCase(items) {\n      if (items instanceof Array) {\n        const loweredRoles = [];\n\n        for (let i = 0; i < items.length; i++) {\n          loweredRoles[i] = items[i].toLowerCase();\n        }\n\n        return loweredRoles;\n      } else if (typeof items === 'string' || items instanceof String) {\n        return items.toLowerCase();\n      }\n    }\n\n    static uniqueId() {\n      return this.randomNumber(1000000, 9000000).toString();\n    }\n\n    static randomNumber(min, max) {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n\n    static baseUrl() {\n      let base = '';\n\n      if (window.location.origin) {\n        base = window.location.origin;\n      } else {\n        base = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n      }\n\n      return base.replace(/\\/$/, '');\n    }\n\n    static printDateOnly(date) {\n      date = new Date(date);\n      const dayNames = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday');\n      const monthNames = new Array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December');\n      const dayOfWeek = date.getDay();\n      const dayOfMonth = date.getDate();\n      let sup = '';\n      const month = date.getMonth();\n      const year = date.getFullYear();\n\n      if (dayOfMonth === 1 || dayOfMonth === 21 || dayOfMonth === 31) {\n        sup = 'st';\n      } else if (dayOfMonth === 2 || dayOfMonth === 22) {\n        sup = 'nd';\n      } else if (dayOfMonth === 3 || dayOfMonth === 23) {\n        sup = 'rd';\n      } else {\n        sup = 'th';\n      }\n\n      const dateString = dayNames[dayOfWeek] + ', ' + dayOfMonth + sup + ' ' + monthNames[month] + ' ' + year;\n      return dateString;\n    }\n\n    static printTimeOnly(date) {\n      date = new Date(date);\n      let period = '';\n      let minute = date.getMinutes().toString();\n      let hour = date.getHours();\n      period = hour < 12 ? 'AM' : 'PM';\n\n      if (hour === 0) {\n        hour = 12;\n      }\n\n      if (hour > 12) {\n        hour = hour - 12;\n      }\n\n      if (minute.length === 1) {\n        minute = '0' + minute;\n      }\n\n      const timeString = hour + ':' + minute + ' ' + period;\n      return timeString;\n    }\n\n    static printDate(date, separator = 'at') {\n      return `${Utilities.printDateOnly(date)} ${separator} ${Utilities.printTimeOnly(date)}`;\n    }\n\n    static printFriendlyDate(date, separator = '-') {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      const yesterday = new Date(today);\n      yesterday.setDate(yesterday.getDate() - 1);\n      const test = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n\n      if (test.toDateString() === today.toDateString()) {\n        return `Today ${separator} ${Utilities.printTimeOnly(date)}`;\n      }\n\n      if (test.toDateString() === yesterday.toDateString()) {\n        return `Yesterday ${separator} ${Utilities.printTimeOnly(date)}`;\n      } else {\n        return Utilities.printDate(date, separator);\n      }\n    }\n\n    static printShortDate(date, separator = '/', dateTimeSeparator = '-') {\n      let day = date.getDate().toString();\n      let month = (date.getMonth() + 1).toString();\n      const year = date.getFullYear();\n\n      if (day.length === 1) {\n        day = '0' + day;\n      }\n\n      if (month.length === 1) {\n        month = '0' + month;\n      }\n\n      return `${month}${separator}${day}${separator}${year} ${dateTimeSeparator} ${Utilities.printTimeOnly(date)}`;\n    }\n\n    static parseDate(date) {\n      if (date) {\n        if (date instanceof Date) {\n          return date;\n        }\n\n        if (typeof date === 'string' || date instanceof String) {\n          if (date.search(/[a-su-z+]/i) === -1) {\n            date = date + 'Z';\n          }\n\n          return new Date(date);\n        }\n\n        if (typeof date === 'number' || date instanceof Number) {\n          return new Date(date);\n        }\n      }\n    }\n\n    static printDuration(start, end) {\n      start = new Date(start);\n      end = new Date(end); // get total seconds between the times\n\n      let delta = Math.abs(start.valueOf() - end.valueOf()) / 1000; // calculate (and subtract) whole days\n\n      const days = Math.floor(delta / 86400);\n      delta -= days * 86400; // calculate (and subtract) whole hours\n\n      const hours = Math.floor(delta / 3600) % 24;\n      delta -= hours * 3600; // calculate (and subtract) whole minutes\n\n      const minutes = Math.floor(delta / 60) % 60;\n      delta -= minutes * 60; // what's left is seconds\n\n      const seconds = delta % 60; // in theory the modulus is not required\n\n      let printedDays = '';\n\n      if (days) {\n        printedDays = `${days} days`;\n      }\n\n      if (hours) {\n        printedDays += printedDays ? `, ${hours} hours` : `${hours} hours`;\n      }\n\n      if (minutes) {\n        printedDays += printedDays ? `, ${minutes} minutes` : `${minutes} minutes`;\n      }\n\n      if (seconds) {\n        printedDays += printedDays ? ` and ${seconds} seconds` : `${seconds} seconds`;\n      }\n\n      if (!printedDays) {\n        printedDays = '0';\n      }\n\n      return printedDays;\n    }\n\n    static getAge(birthDate, otherDate) {\n      birthDate = new Date(birthDate);\n      otherDate = new Date(otherDate);\n      let years = otherDate.getFullYear() - birthDate.getFullYear();\n\n      if (otherDate.getMonth() < birthDate.getMonth() || otherDate.getMonth() === birthDate.getMonth() && otherDate.getDate() < birthDate.getDate()) {\n        years--;\n      }\n\n      return years;\n    }\n\n    static searchArray(searchTerm, caseSensitive, ...values) {\n      if (!searchTerm) {\n        return true;\n      }\n\n      let filter = searchTerm.trim();\n      let data = values.join();\n\n      if (!caseSensitive) {\n        filter = filter.toLowerCase();\n        data = data.toLowerCase();\n      }\n\n      return data.indexOf(filter) !== -1;\n    }\n\n    static moveArrayItem(array, oldIndex, newIndex) {\n      if (oldIndex < 0) {\n        return;\n      }\n\n      if (newIndex < 0) {\n        newIndex += array.length;\n      }\n\n      if (newIndex >= array.length) {\n        let k = newIndex - array.length;\n\n        while (k-- + 1) {\n          array.push(undefined);\n        }\n      }\n\n      array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);\n    }\n\n    static expandCamelCase(text) {\n      if (!text) {\n        return text;\n      }\n\n      return text.replace(/([A-Z][a-z]+)/g, ' $1').replace(/([A-Z][A-Z]+)/g, ' $1').replace(/([^A-Za-z ]+)/g, ' $1');\n    }\n\n    static testIsAbsoluteUrl(url) {\n      const r = new RegExp('^(?:[a-z]+:)?//', 'i');\n      return r.test(url);\n    }\n\n    static convertToAbsoluteUrl(url) {\n      return Utilities.testIsAbsoluteUrl(url) ? url : '//' + url;\n    }\n\n    static removeNulls(obj) {\n      const isArray = obj instanceof Array;\n\n      for (const k in obj) {\n        if (!obj.hasOwnProperty(k)) {\n          continue;\n        }\n\n        if (obj[k] === null) {\n          ///isArray ? obj.splice(k, 1) : delete obj[k];\n          isArray ? obj.splice(1, 0, k) : delete obj[k];\n        } else if (typeof obj[k] === 'object') {\n          Utilities.removeNulls(obj[k]);\n        }\n\n        if (isArray && obj.length === +k) {\n          Utilities.removeNulls(obj);\n        }\n      }\n\n      return obj;\n    }\n\n    static debounce(func, wait, immediate) {\n      let timeout;\n      return function () {\n        const context = this;\n        const args = arguments;\n\n        const later = () => {\n          timeout = null;\n\n          if (!immediate) {\n            func.apply(context, args);\n          }\n        };\n\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n\n        if (callNow) {\n          func.apply(context, args);\n        }\n      };\n    }\n\n  }\n\n  Utilities.captionAndMessageSeparator = ':';\n  Utilities.noNetworkMessageCaption = 'No Network';\n  Utilities.noNetworkMessageDetail = 'The server cannot be reached';\n  Utilities.accessDeniedMessageCaption = 'Access Denied!';\n  Utilities.accessDeniedMessageDetail = '';\n  Utilities.notFoundMessageCaption = 'Not Found';\n  Utilities.notFoundMessageDetail = 'The target resource cannot be found';\n  Utilities.cookies = {\n    getItem: sKey => {\n      return decodeURIComponent(document.cookie.replace(new RegExp('(?:(?:^|.*;)\\\\s*' + encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, '\\\\$&') + '\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$'), '$1')) || null;\n    },\n    setItem: (sKey, sValue, vEnd, sPath, sDomain, bSecure) => {\n      if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) {\n        return false;\n      }\n\n      let sExpires = '';\n\n      if (vEnd) {\n        switch (vEnd.constructor) {\n          case Number:\n            sExpires = vEnd === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + vEnd;\n            break;\n\n          case String:\n            sExpires = '; expires=' + vEnd;\n            break;\n\n          case Date:\n            sExpires = '; expires=' + vEnd.toUTCString();\n            break;\n        }\n      }\n\n      document.cookie = encodeURIComponent(sKey) + '=' + encodeURIComponent(sValue) + sExpires + (sDomain ? '; domain=' + sDomain : '') + (sPath ? '; path=' + sPath : '') + (bSecure ? '; secure' : '');\n      return true;\n    },\n    removeItem: (sKey, sPath, sDomain) => {\n      if (!sKey) {\n        return false;\n      }\n\n      document.cookie = encodeURIComponent(sKey) + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT' + (sDomain ? '; domain=' + sDomain : '') + (sPath ? '; path=' + sPath : '');\n      return true;\n    },\n    hasItem: sKey => {\n      return new RegExp('(?:^|;\\\\s*)' + encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, '\\\\$&') + '\\\\s*\\\\=').test(document.cookie);\n    },\n    keys: () => {\n      const aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, '').split(/\\s*(?:\\=[^;]*)?;\\s*/);\n\n      for (let nIdx = 0; nIdx < aKeys.length; nIdx++) {\n        aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);\n      }\n\n      return aKeys;\n    }\n  };\n\n  Utilities.ɵfac = function Utilities_Factory(t) {\n    return new (t || Utilities)();\n  };\n\n  Utilities.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: Utilities,\n    factory: Utilities.ɵfac\n  });\n  return Utilities;\n})();","map":null,"metadata":{},"sourceType":"module"}