{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { ConfigurationService } from './configuration.service';\nimport { DBkeys } from './db-keys';\nimport { JwtHelper } from './jwt-helper';\nimport { Utilities } from './utilities';\nimport { User } from '../models/user.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"./oidc-helper.service\";\nimport * as i3 from \"./configuration.service\";\nimport * as i4 from \"./local-store-manager.service\";\nexport let AuthService = /*#__PURE__*/(() => {\n  class AuthService {\n    constructor(router, oidcHelperService, configurations, localStorage) {\n      this.router = router;\n      this.oidcHelperService = oidcHelperService;\n      this.configurations = configurations;\n      this.localStorage = localStorage;\n      this.previousIsLoggedInCheck = false;\n      this.loginStatus = new Subject();\n      this.initializeLoginStatus();\n    }\n\n    get loginUrl() {\n      return this.configurations.loginUrl;\n    }\n\n    get homeUrl() {\n      return this.configurations.homeUrl;\n    }\n\n    initializeLoginStatus() {\n      this.localStorage.getInitEvent().subscribe(() => {\n        this.reevaluateLoginStatus();\n      });\n    }\n\n    gotoPage(page, preserveParams = true) {\n      const navigationExtras = {\n        queryParamsHandling: preserveParams ? 'merge' : '',\n        preserveFragment: preserveParams\n      };\n      this.router.navigate([page], navigationExtras);\n    }\n\n    gotoHomePage() {\n      this.router.navigate([this.homeUrl]);\n    }\n\n    redirectLoginUser() {\n      const redirect = this.loginRedirectUrl && this.loginRedirectUrl !== '/' && this.loginRedirectUrl !== ConfigurationService.defaultHomeUrl ? this.loginRedirectUrl : this.homeUrl;\n      this.loginRedirectUrl = null;\n      const urlParamsAndFragment = Utilities.splitInTwo(redirect, '#');\n      const urlAndParams = Utilities.splitInTwo(urlParamsAndFragment.firstPart, '?');\n      const navigationExtras = {\n        fragment: urlParamsAndFragment.secondPart,\n        queryParams: Utilities.getQueryParamsFromString(urlAndParams.secondPart),\n        queryParamsHandling: 'merge'\n      };\n      this.router.navigate([urlAndParams.firstPart], navigationExtras);\n    }\n\n    redirectLogoutUser() {\n      const redirect = this.logoutRedirectUrl ? this.logoutRedirectUrl : this.loginUrl;\n      this.logoutRedirectUrl = null;\n      this.router.navigate([redirect]);\n    }\n\n    redirectForLogin() {\n      this.loginRedirectUrl = this.router.url;\n      this.router.navigate([this.loginUrl]);\n    }\n\n    reLogin() {\n      if (this.reLoginDelegate) {\n        this.reLoginDelegate();\n      } else {\n        this.redirectForLogin();\n      }\n    }\n\n    refreshLogin() {\n      return this.oidcHelperService.refreshLogin().pipe(map(resp => this.processLoginResponse(resp, this.rememberMe)));\n    }\n\n    loginWithPassword(userName, password, rememberMe) {\n      if (this.isLoggedIn) {\n        this.logout();\n      }\n\n      return this.oidcHelperService.loginWithPassword(userName, password).pipe(map(resp => this.processLoginResponse(resp, rememberMe)));\n    }\n\n    processLoginResponse(response, rememberMe) {\n      const accessToken = response.access_token;\n\n      if (accessToken == null) {\n        throw new Error('accessToken cannot be null');\n      }\n\n      rememberMe = rememberMe || this.rememberMe;\n      const refreshToken = response.refresh_token || this.refreshToken;\n      const expiresIn = response.expires_in;\n      const tokenExpiryDate = new Date();\n      tokenExpiryDate.setSeconds(tokenExpiryDate.getSeconds() + expiresIn);\n      const accessTokenExpiry = tokenExpiryDate;\n      const jwtHelper = new JwtHelper();\n      const decodedAccessToken = jwtHelper.decodeToken(accessToken);\n      const permissions = Array.isArray(decodedAccessToken.permission) ? decodedAccessToken.permission : [decodedAccessToken.permission];\n\n      if (!this.isLoggedIn) {\n        this.configurations.import(decodedAccessToken.configuration);\n      }\n\n      const user = new User(decodedAccessToken.sub, decodedAccessToken.name, decodedAccessToken.fullname, decodedAccessToken.email, decodedAccessToken.jobtitle, decodedAccessToken.phone_number, Array.isArray(decodedAccessToken.role) ? decodedAccessToken.role : [decodedAccessToken.role]);\n      user.isEnabled = true;\n      this.saveUserDetails(user, permissions, accessToken, refreshToken, accessTokenExpiry, rememberMe);\n      this.reevaluateLoginStatus(user);\n      return user;\n    }\n\n    saveUserDetails(user, permissions, accessToken, refreshToken, expiresIn, rememberMe) {\n      if (rememberMe) {\n        this.localStorage.savePermanentData(accessToken, DBkeys.ACCESS_TOKEN);\n        this.localStorage.savePermanentData(refreshToken, DBkeys.REFRESH_TOKEN);\n        this.localStorage.savePermanentData(expiresIn, DBkeys.TOKEN_EXPIRES_IN);\n        this.localStorage.savePermanentData(permissions, DBkeys.USER_PERMISSIONS);\n        this.localStorage.savePermanentData(user, DBkeys.CURRENT_USER);\n      } else {\n        this.localStorage.saveSyncedSessionData(accessToken, DBkeys.ACCESS_TOKEN);\n        this.localStorage.saveSyncedSessionData(refreshToken, DBkeys.REFRESH_TOKEN);\n        this.localStorage.saveSyncedSessionData(expiresIn, DBkeys.TOKEN_EXPIRES_IN);\n        this.localStorage.saveSyncedSessionData(permissions, DBkeys.USER_PERMISSIONS);\n        this.localStorage.saveSyncedSessionData(user, DBkeys.CURRENT_USER);\n      }\n\n      this.localStorage.savePermanentData(rememberMe, DBkeys.REMEMBER_ME);\n    }\n\n    logout() {\n      this.localStorage.deleteData(DBkeys.ACCESS_TOKEN);\n      this.localStorage.deleteData(DBkeys.REFRESH_TOKEN);\n      this.localStorage.deleteData(DBkeys.TOKEN_EXPIRES_IN);\n      this.localStorage.deleteData(DBkeys.USER_PERMISSIONS);\n      this.localStorage.deleteData(DBkeys.CURRENT_USER);\n      this.configurations.clearLocalChanges();\n      this.reevaluateLoginStatus();\n    }\n\n    reevaluateLoginStatus(currentUser) {\n      const user = currentUser || this.localStorage.getDataObject(DBkeys.CURRENT_USER);\n      const isLoggedIn = user != null;\n\n      if (this.previousIsLoggedInCheck !== isLoggedIn) {\n        setTimeout(() => {\n          this.loginStatus.next(isLoggedIn);\n        });\n      }\n\n      this.previousIsLoggedInCheck = isLoggedIn;\n    }\n\n    getLoginStatusEvent() {\n      return this.loginStatus.asObservable();\n    }\n\n    get currentUser() {\n      const user = this.localStorage.getDataObject(DBkeys.CURRENT_USER);\n      this.reevaluateLoginStatus(user);\n      return user;\n    }\n\n    get userPermissions() {\n      return this.localStorage.getDataObject(DBkeys.USER_PERMISSIONS) || [];\n    }\n\n    get accessToken() {\n      return this.oidcHelperService.accessToken;\n    }\n\n    get accessTokenExpiryDate() {\n      return this.oidcHelperService.accessTokenExpiryDate;\n    }\n\n    get refreshToken() {\n      return this.oidcHelperService.refreshToken;\n    }\n\n    get isSessionExpired() {\n      return this.oidcHelperService.isSessionExpired;\n    }\n\n    get isLoggedIn() {\n      return this.currentUser != null;\n    }\n\n    get rememberMe() {\n      return this.localStorage.getDataObject(DBkeys.REMEMBER_ME) === true;\n    }\n\n  }\n\n  AuthService.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.OidcHelperService), i0.ɵɵinject(i3.ConfigurationService), i0.ɵɵinject(i4.LocalStoreManager));\n  };\n\n  AuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac\n  });\n  return AuthService;\n})();","map":null,"metadata":{},"sourceType":"module"}