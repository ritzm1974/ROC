{"ast":null,"code":"import { interval } from 'rxjs';\nimport { map, mergeMap, startWith } from 'rxjs/operators';\nimport { Notification } from '../models/notification.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./notification-endpoint.service\";\nimport * as i2 from \"./auth.service\";\nexport let NotificationService = /*#__PURE__*/(() => {\n  class NotificationService {\n    constructor(notificationEndpoint, authService) {\n      this.notificationEndpoint = notificationEndpoint;\n      this.authService = authService;\n    }\n\n    get currentUser() {\n      return this.authService.currentUser;\n    }\n\n    get recentNotifications() {\n      return this._recentNotifications;\n    }\n\n    set recentNotifications(notifications) {\n      this._recentNotifications = notifications;\n    }\n\n    getNotification(notificationId) {\n      return this.notificationEndpoint.getNotificationEndpoint(notificationId).pipe(map(response => Notification.Create(response)));\n    }\n\n    getNotifications(page, pageSize) {\n      return this.notificationEndpoint.getNotificationsEndpoint(page, pageSize).pipe(map(response => {\n        return this.getNotificationsFromResponse(response);\n      }));\n    }\n\n    getUnreadNotifications(userId) {\n      return this.notificationEndpoint.getUnreadNotificationsEndpoint(userId).pipe(map(response => this.getNotificationsFromResponse(response)));\n    }\n\n    getNewNotifications() {\n      return this.notificationEndpoint.getNewNotificationsEndpoint(this.lastNotificationDate).pipe(map(response => this.processNewNotificationsFromResponse(response)));\n    }\n\n    getNewNotificationsPeriodically() {\n      return interval(10000).pipe(startWith(0), mergeMap(() => {\n        return this.notificationEndpoint.getNewNotificationsEndpoint(this.lastNotificationDate).pipe(map(response => this.processNewNotificationsFromResponse(response)));\n      }));\n    }\n\n    pinUnpinNotification(notificationOrNotificationId, isPinned) {\n      if (typeof notificationOrNotificationId === 'number' || notificationOrNotificationId instanceof Number) {\n        return this.notificationEndpoint.getPinUnpinNotificationEndpoint(notificationOrNotificationId, isPinned);\n      } else {\n        return this.pinUnpinNotification(notificationOrNotificationId.id);\n      }\n    }\n\n    readUnreadNotification(notificationIds, isRead) {\n      return this.notificationEndpoint.getReadUnreadNotificationEndpoint(notificationIds, isRead);\n    }\n\n    deleteNotification(notificationOrNotificationId) {\n      if (typeof notificationOrNotificationId === 'number' || notificationOrNotificationId instanceof Number) {\n        // Todo: Test me if its check is valid\n        return this.notificationEndpoint.getDeleteNotificationEndpoint(notificationOrNotificationId).pipe(map(response => {\n          this.recentNotifications = this.recentNotifications.filter(n => n.id !== notificationOrNotificationId);\n          return Notification.Create(response);\n        }));\n      } else {\n        return this.deleteNotification(notificationOrNotificationId.id);\n      }\n    }\n\n    processNewNotificationsFromResponse(response) {\n      const notifications = this.getNotificationsFromResponse(response);\n\n      for (const n of notifications) {\n        if (n.date > this.lastNotificationDate) {\n          this.lastNotificationDate = n.date;\n        }\n      }\n\n      return notifications;\n    }\n\n    getNotificationsFromResponse(response) {\n      const notifications = [];\n\n      for (const i in response) {\n        if (response.hasOwnProperty(i)) {\n          notifications[i] = Notification.Create(response[i]);\n        }\n      }\n\n      notifications.sort((a, b) => b.date.valueOf() - a.date.valueOf());\n      notifications.sort((a, b) => a.isPinned === b.isPinned ? 0 : a.isPinned ? -1 : 1);\n      this.recentNotifications = notifications;\n      return notifications;\n    }\n\n  }\n\n  NotificationService.ɵfac = function NotificationService_Factory(t) {\n    return new (t || NotificationService)(i0.ɵɵinject(i1.NotificationEndpoint), i0.ɵɵinject(i2.AuthService));\n  };\n\n  NotificationService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NotificationService,\n    factory: NotificationService.ɵfac\n  });\n  return NotificationService;\n})();","map":null,"metadata":{},"sourceType":"module"}